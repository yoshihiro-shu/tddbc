package tddbc

import "fmt"

type ClosedRange struct {
	Num1, Num2 int
}

func NewClosedRange(a, b int) *ClosedRange {
	return &ClosedRange{a, b}
}

// 課題1-1 上端点、下端点
// 下端点と上端点を与えて閉区間を生成し、閉区間から下端点と上端点を取得してみましょう

// TODO:
// -[x] (1, 10)の時、下端点は1を返す
// -[x] (1, 10)の時、上端点は10を返す
// -[x] (10, 1)の時、下端点は1を返す
// -[x] (10, 1)の時、上端点は10を返す
// -[x] (1, 1)の時、下端点は1を返す
// -[x] (1, 1)の時、上端点は1を返す
// -[x] (10, 10)の時、下端点は10を返す <- 重複しているテストケース
// -[x] (10, 10)の時、上端点は10を返す <- 重複しているテストケース

func (c *ClosedRange) LowerEndpoint() int {
	if c.Num1 > c.Num2 {
		return c.Num2
	}
	return c.Num1
}

func (c *ClosedRange) UpperEndpoint() int {
	if c.Num1 > c.Num2 {
		return c.Num1
	}
	return c.Num2
}

// 課題1-2 文字列表現 "[a,b]"
// 閉区間から文字列表現を取得してみましょう

// TODO:
// -[x] (1, 10)の時、"[1,10]"を返す
// -[x] (10, 1)の時、"[1,10]"を返す
// -[x] (1, 1)の時、"[1,1]"を返す
// -[x] (10, 10)の時、"[10,10]"を返す <- 重複しているテストケース

func (c *ClosedRange) ToString() string {
	return fmt.Sprintf(`"[%d,%d]"`, c.LowerEndpoint(), c.UpperEndpoint())
}

// 課題1-3 帰属
// 閉区間が指定した整数を含むか (contains) 判定してみましょう

// -[x] [1,10]は、5を含む      <- 代表値
// -[x] [1,10]は、0を含まない 　<- 境界値
// -[x] [1,10]は、11を含まない　<- 境界値
// -[x] [1,10]は、1を含む　　　 <- 境界値
// -[x] [1,10]は、10を含む     <- 境界値
// -[x] [1,1]は、-1を含まない  <- 重複しているテストケース
// -[x] [1,1]は、1を含む       <- 代表値
// -[x] [1,1]は、10を含まない  <- 重複しているテストケース

func (c *ClosedRange) Contains(n int) bool {
	return (c.LowerEndpoint() <= n) && (n <= c.UpperEndpoint())
}

// 疑問

// テストケースを作るときに意識することはあるのか？
// 今回の場合だと、境界値のテストケースをかなり意識した

// 品質保証に必要なテストケースは4つ
// 境界値前後の4つ

// おかわり
// 整数開区間を示すクラス（あるいは構造体）をつくりたい。
// 整数開区間は下端点と上端点を持ち、文字列としても表現できる
// （例: 下端点 3, 上端点 8 の整数開区間の文字列表記は "(3,8)"）。
// ただし、上端点より下端点が大きい開区間を作ることはできない。
// 整数の開区間は指定した整数を含むかどうかを判定できる。
// また、別の開区間と等価かどうかや、完全に含まれるかどうかも判定できる。
// なお、先に作成した閉区間クラスとのコードの重複がなるべく発生しないようにしたい

// TODO List
// -[] 整数開区間は下端点と上端点を持つ
//   -[] (1, 10)の時、下端点は2を返す
//   -[] (1, 10)の時、上端点は9を返す
//   -[] (3, 8)の時、下端点は4を返す
//   -[] (3, 8)の時、上端点は7を返す
// -[] 整数の開区間は指定した整数を含むかどうかを判定できる。
//   -[] (1,10)は、1を含まない
//   -[] (1,10)は、10を含まない
//   -[] (1,10)は、2を含む
//   -[] (1,10)は、9を含む
// -[] 別の開区間と等価かどうかや、完全に含まれるかどうかも判定できる。
//   -[] (1, 10)に(2, 9)は完全に含まれる
//   -[] (1, 10)に(11, 20)は含まれない
// -[] 文字列としても表現できる
//   -[] (1, 10)は、 "(1,10)"と出力される
//   -[] (3, 8)は、 "(3,8)"と出力される
